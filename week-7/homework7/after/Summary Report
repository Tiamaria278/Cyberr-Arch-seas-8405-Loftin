# Summary Report: Securing Containerized Microservices

## Steps Taken
1. **Environment Setup**: Launched the vulnerable Python Flask app using `make start`, tested its endpoints, and scanned for issues using `make check`, `make scan`, and `make host-security`.
2. **Code Remediation**: 
   - Replaced `eval()` with `ast.literal_eval()` to prevent arbitrary code execution.
   - Added input validation to sanitize user inputs.
   - Removed hardcoded passwords and loaded secrets from a `.env` file.
   - Restricted the Flask app to `127.0.0.1`.
3. **Docker Hardening**:
   - Used a slim Python base image to reduce the attack surface.
   - Ensured the app runs as a non-root user.
   - Added a `HEALTHCHECK` and limited resources using `mem_limit` and `pids_limit`.
   - Created a `.env` file and implemented `.env` loading via `docker-compose.yml`.
4. **Threat Modeling**:
   - Performed STRIDE analysis identifying spoofing, tampering, and elevation of privilege.
   - Mapped MITRE ATT&CK techniques (e.g., T1059, T1203).
   - Mapped controls to NIST 800-53 standards (e.g., AC-6, SC-12).
5. **Security Architecture**:
   - Designed a secure architecture diagram including user interface, proxy layer, hardened Flask app, and container.
6. **Automation**:
   - Developed `docker_security_fixes.py` to update Docker daemon configuration and patch Dockerfile with best practices.

## Vulnerabilities Found and Fixed
- Command injection in `/ping` endpoint.
- Use of `eval()` in calculation logic.
- Hardcoded credentials in code.
- Root user in container runtime.
- Lack of resource limits and health monitoring.

## Architecture Improvements
- The redesigned container setup uses least-privilege principles.
- Environment secrets are externalized using `.env`.
- The system includes memory, process, and health constraints.
- Attack surfaces are minimized through hardened Docker configuration and strict input handling.

## Lessons Learned
This assignment highlighted the importance of defense-in-depth and secure software development practices. Simple oversights, like hardcoded secrets or unsafe function usage, can introduce critical vulnerabilities. Applying STRIDE and MITRE frameworks provided structured insights into system threats, while Docker hardening techniques improved deployment security. This practical exercise reinforced the significance of layered security, compliance alignment, and automated remediation within the SSDLC lifecycle.
